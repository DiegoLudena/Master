# -*- coding: utf-8 -*-
"""IABD_MP4_T04_01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lM0Le2OaR48MCcZBFNUMlws9aa0orjeg

EJERCICIO 1: Pandas vs Polars:
o	Carga un conjunto de datos grande (un CSV o un archivo de texto) en Python.
o	Realiza algunas operaciones básicas como filtrado, ordenación y agregación de datos utilizando tanto Pandas como Polars.
o	Compara el tiempo de ejecución de las operaciones en ambos casos.
"""

import pandas as pd
import polars as pl
import time

import re

import matplotlib.pyplot as plt
import numpy as np


# Cargar datos con Pandas
inicio = time.time()
df_pandas = pd.read_csv("anime-dataset-2023.csv")
tiempo_carga_pandas = time.time() - inicio

# Cargar datos con Polars
# Polaris interpeta el tipo de una columna al fijarse en el primer dato.
# Al ser Score una columna de float, encontrar texto hace que lance un ComputeError
# Se añade 'UNKNOWN' a la lista de null_values para que Polars
# lo trate como un valor nulo en la columna 'Score'
inicio = time.time()
df_polars = pl.read_csv("anime-dataset-2023.csv", null_values=["UNKNOWN"])
tiempo_carga_polars = time.time() - inicio

print(f"Tiempo de carga con Pandas: {tiempo_carga_pandas} segundos")
print(f"Tiempo de carga con Polars: {tiempo_carga_polars} segundos")

# Mostrar las primeras filas del DataFrame, incluyendo los tipos de datos con pandas
print(df_pandas.head())

# Obtener información más detallada sobre los tipos de datos de cada columna con pandas
print(df_pandas.dtypes)

# Mostrar las primeras filas del DataFrame, incluyendo los tipos de datos con polars
print(df_polars.head())

# Obtener información más detallada sobre los tipos de datos de cada columna con polars
print(df_polars.schema)

# Filtrado de los animes con mejor nota
inicio = time.time()
# Como hay valores "UNKNOWN" en la columna, los hacemos nulos y evitamos que los considere
df_pandas["Score"] = pd.to_numeric(df_pandas["Score"], errors='coerce')
filtro_pandas = df_pandas[df_pandas["Score"] > 7.5]
tiempo_filtro_pandas = time.time() - inicio

inicio = time.time()
filtro_polars = df_polars.filter(pl.col("Score") > 7.5)
tiempo_filtro_polars = time.time() - inicio

# Ordenamiento por rango
inicio = time.time()
orden_pandas = df_pandas.sort_values(by=["Rank"])
tiempo_orden_pandas = time.time() - inicio

inicio = time.time()
orden_polars = df_polars.sort("Rank")
tiempo_orden_polars = time.time() - inicio

# Agregación: Cantidad de animes por estudio:

inicio = time.time()
animes_por_estudio_pandas = df_pandas.groupby("Studios")["Name"].count()
tiempo_agregado_pandas = time.time() - inicio

inicio = time.time()
animes_por_estudio_polars = df_polars.group_by("Studios").agg(pl.col("Name").count())
tiempo_agregado_polars = time.time() - inicio

# Consideramos que crear una nueva columna para el dataframe
# y cambiar el tipo de dato también son operaciones habituales (de hecho ya lo hemos hecho)
# y queremos compararlas:

# Calcular el total de favoritos
inicio = time.time()
total_favoritos = df_pandas['Favorites'].sum()

# Calcular el porcentaje de favoritos y crear la nueva columna con Pandas
df_pandas['Favorites_percentage'] = (df_pandas['Favorites'] / total_favoritos) * 100
tiempo_columna_pandas = time.time() - inicio

# Calcular el total de favoritos y crear la nueva columna con Polars
inicio = time.time()
df_polars = df_polars.with_columns(
    (pl.col("Favorites") / pl.col("Favorites").sum() * 100).alias("Favorites_percentage")
)
tiempo_columna_polars = time.time() - inicio

# Como Scored By es tipo Object pero debería ser un numero entero vamos a cambiarlo:

# Convertir la columna "Scored By" a tipo entero, manejando errores con 'coerce' con Pandas
df_pandas["Scored By"] = pd.to_numeric(df_pandas["Scored By"], errors='coerce')
df_pandas["Scored By"] = df_pandas["Scored By"].astype("Int64")
tiempo_cambio_tipo_pandas = time.time() - inicio


# Convertir la columna "Scored By" a tipo entero (Int64) con Polars
df_polars = df_polars.with_columns(pl.col("Scored By").cast(pl.Int64))
tiempo_cambio_tipo_polars = time.time() - inicio


print(f"Tiempo de filtrado con Pandas: {tiempo_filtro_pandas} segundos")
print(f"Tiempo de filtrado con Polars: {tiempo_filtro_polars} segundos")
print(f"Tiempo de ordenamiento con Pandas: {tiempo_orden_pandas} segundos")
print(f"Tiempo de ordenamiento con Polars: {tiempo_orden_polars} segundos")
print(f"Tiempo de agregación con Pandas: {tiempo_agregado_pandas} segundos")
print(f"Tiempo de agregación con Polars: {tiempo_agregado_polars} segundos")
print(f"Tiempo de nueva columna Pandas: {tiempo_columna_pandas} segundos")
print(f"Tiempo de nueva columna Polars: {tiempo_columna_polars} segundos")
print(f"Tiempo de cambio de tipo con Pandas: {tiempo_cambio_tipo_pandas} segundos")
print(f"Tiempo de cambio de tipo con Polars: {tiempo_cambio_tipo_polars} segundos")

# Datos de tiempos de ejecución
tiempos_pandas = [tiempo_carga_pandas, tiempo_filtro_pandas, tiempo_orden_pandas, tiempo_agregado_pandas, tiempo_columna_pandas, tiempo_cambio_tipo_pandas]
tiempos_polars = [tiempo_carga_polars, tiempo_filtro_polars, tiempo_orden_polars, tiempo_agregado_polars, tiempo_columna_polars, tiempo_cambio_tipo_polars]

# Operaciones
operaciones = ['Carga', 'Filtrado', 'Ordenamiento', 'Agregación', 'Nueva columna', 'Cambio de tipo']

# Crear la figura y los subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8))  # 2 filas, 1 columna

# Gráfico 1: Tiempos absolutos
x = np.arange(len(operaciones))
width = 0.35

rects1 = ax1.bar(x - width/2, tiempos_pandas, width, label='Pandas')
rects2 = ax1.bar(x + width/2, tiempos_polars, width, label='Polars')

ax1.set_ylabel('Tiempo (segundos)')
ax1.set_title('Comparación de tiempos de ejecución: Pandas vs Polars')
ax1.set_xticks(x)
ax1.set_xticklabels(operaciones)
ax1.legend()

# Gráfico 2: Diferencias en porcentajes
diferencias_porcentaje = [(tp - tpd) / tpd * 100 for tpd, tp in zip(tiempos_pandas, tiempos_polars)]

# Crear una lista de colores basada en las diferencias
colores = ['orange' if diff < 0 else 'blue' for diff in diferencias_porcentaje]

rects3 = ax2.bar(x, diferencias_porcentaje, width, label='Diferencia (%)', color=colores)

# Añadir etiquetas con los porcentajes en las columnas
for i, rect in enumerate(rects3):
    height = rect.get_height()
    ax2.text(rect.get_x() + rect.get_width() / 2, height + (height * 0.02),  # Ajustar la posición vertical del texto
            f'{diferencias_porcentaje[i]:.2f}%', ha='center', va='bottom', color='black')

ax2.set_ylabel('Diferencia (%)')
ax2.spines['bottom'].set_position('zero')
ax2.set_xticks(x)
ax2.set_xticklabels(operaciones)
ax2.legend()

# Ajustar el espacio entre los subplots
plt.tight_layout()

# Mostrar el gráfico
plt.show()