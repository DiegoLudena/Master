# -*- coding: utf-8 -*-
"""IABD_MP5_T02_04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hfAnhWIxrSYMIBTT1abC1sjQW_j0rEmY

Diseñar un sistema distribuido simple y probar su tolerancia a fallos mediante
 un programa en Python.
Instrucciones:
1.	Simulación de un sistema distribuido:
o	Imagina un sistema de almacenamiento distribuido simple donde los datos se
replican en tres nodos.
o	Crea un programa que simule el almacenamiento de datos en estos nodos.
2.	Simulación de fallos:
o	Introduce un fallo en uno de los nodos y muestra cómo el sistema puede seguir
operando usando los otros dos nodos.
o	Muestra cómo se podrían recuperar los datos desde un nodo que ha fallado.
En este caso deberemos crear de tres a cinco nodos que puedan contener
datos en su interior (hemos de analizar que estructura de datos es la más adecuada para estos nodos).
Deberemos almacenar los datos (creados por nosotros mismos) en esta estructura
 de datos y luego gestionar un fallo de estos nodos, recuperando
 así la información.
*Los datos se deberán replicar en los otros nodos

*Sharding opcional recomendado

Primero, analicemos la estructura de datos más adecuada para los nodos. Dado que necesitamos replicar los datos en los otros nodos, una buena opción sería utilizar un diccionario. Esto nos permitirá almacenar los datos de forma clave-valor y acceder a ellos fácilmente.
"""

import itertools
import random

class Nodo:
    def __init__(self, id_nodo):
        self.id_nodo = id_nodo
        self.datos = {}

    def almacenar_dato(self, clave, valor, num_shards, shards):
        shard = obtener_shard(clave, num_shards)
        if self in shards[shard]:
            self.datos[clave] = valor
    #Definimos la función obtener dato, para que nos diga de qué nodo se ha recuperado y poder comprobar el sistema de recuperación
    def obtener_dato(self, clave, num_shards, shards):
        shard = obtener_shard(clave, num_shards)
        for i, nodo in enumerate(shards[shard]):
            valor = nodo.datos.get(clave)
            if valor is not None:
                if i == 0:
                    print(f"Dato recuperado del nodo principal {nodo.id_nodo}") #nodo principal
                else:
                    print(f"Dato recuperado del nodo réplica {nodo.id_nodo}") #nodo réplica
                return valor
        return None

def obtener_shard(clave, num_shards):
    return hash(clave) % num_shards

# Crear 5 nodos
nodos = [Nodo(i) for i in range(5)]

# Crear 50 datos de ejemplo
datos = {i: f"Dato {i}" for i in range(50)}
"""
Ahora hay que crear los datos y repartirlos entre los nodos. La idea es evitar
la sobrecarga de ningún nodo tanto en el reparto inicial de los datos como en el
de las réplicas, así que se utilizaremos un sistema similar al Round Robin.
Los nodos a elegir se harán, primero con sharding. Al usar sharding se asigna
a cada dato su shard a partir de una función de hash, se busca el grupo de nodos
 del shard y se almacena el dato en ellos. Para mantener el sistema sencillo,
 consideraremos que el nodo en la posición 0 del shard es el nodo principal,
 y los otros dos son los nodos réplica. Para que cada nodo pueda ser principal y
 los datos estén muy repartidos usamos 5 shards y asigaremos el principal,
 el 0, con un iterador cíclico.
"""
# Configurar sharding con 5 shards para que cada nodo sea principal
num_shards = 5
shards = {}
nodos_por_shard = 3  # Número de nodos por shard

# Crear un iterador cíclico de nodos para asignarlos a los shards
iterador_nodos = itertools.cycle(nodos)

for shard_id in range(num_shards):
    # Seleccionar nodos para el shard en orden cíclico
    nodos_shard = [next(iterador_nodos) for _ in range(nodos_por_shard)]
    shards[shard_id] = nodos_shard

# Almacenar datos con sharding y replicación
for clave, valor in datos.items():
    shard = obtener_shard(clave, num_shards)
    for nodo in shards[shard]:
        nodo.almacenar_dato(clave, valor, num_shards, shards)

# Ejemplo de recuperación de datos
clave_ejemplo = 8  # Clave del dato que queremos recuperar
valor = nodos[0].obtener_dato(clave_ejemplo, num_shards, shards) #lo busca en el nodo 0 del shard, el principal

print(f"El valor para la clave {clave_ejemplo} es: {valor}")


# Depuración: Recuperar todos los datos y mostrar los nodos en los que están
for clave in datos:
    shard = obtener_shard(clave, num_shards)
    nodos_con_clave = [nodo.id_nodo for nodo in shards[shard] if clave in nodo.datos]
    print(f"Clave: {clave}, Nodos: {nodos_con_clave}")

"""Ahora hay que simular el fallo de un nodo. Para ello, con random, sacamos un número de 0 a 4 y eliminamos los datos en ese nodo:

---


"""

# Simular fallo de un nodo
nodo_fallido = random.randint(0, 4)
print(f"Simulando fallo del nodo {nodo_fallido}")

# Eliminar datos del nodo fallido
for clave in list(nodos[nodo_fallido].datos.keys()):  # Iterar sobre una copia de las claves
    del nodos[nodo_fallido].datos[clave]

# Depuración: Comprobar que los datos ya no están en el nodo fallido
for clave in datos:
    shard = obtener_shard(clave, num_shards)
    nodos_con_clave = [nodo.id_nodo for nodo in shards[shard] if clave in nodo.datos]
    print(f"Clave: {clave}, Nodos: {nodos_con_clave}")

"""Faltaría recuperar los datos perdidos. Para ello recorremos los shards, detectando aquellos en los que participaba el nodo fallido. Después obtenemos los datos donde están replicados y los reasignamos al nodo caído.

"""

# Recuperar datos del nodo fallido a partir de las réplicas
print(f"Recuperando datos del nodo {nodo_fallido} a partir de las réplicas...")
for shard_id, nodos_shard in shards.items():
    if nodos[nodo_fallido] in nodos_shard:  # Si el nodo fallido estaba en este shard
        # Obtener datos de las réplicas
        datos_replica = {}
        for nodo in nodos_shard:
            if nodo.id_nodo != nodo_fallido:
                datos_replica.update(nodo.datos)

        # Reasignar datos al nodo fallido
        nodos[nodo_fallido].datos.update(datos_replica)

print("Datos recuperados y reasignados.")

# Depuración: Comprobar que los datos vuelven a estar en el nodo fallido
for clave in datos:
    shard = obtener_shard(clave, num_shards)
    nodos_con_clave = [nodo.id_nodo for nodo in shards[shard] if clave in nodo.datos]
    print(f"Clave: {clave}, Nodos: {nodos_con_clave}")

"""Los nodos vuelven a estar en su sitio. Notar que los nodos vuelven a su posición original (los que tenían el nodo caído como nodo principal lo mantienen, así como los que los tenían en la posición 1 o 2 también) porque no hemos eliminado completamente el nodo del del shard, si no que solamente se ha eliminado lo que había dentro. Sería como haber simulado un borrado de datos, pero no que el sistema haya fallado de forma total y deba ser sustituido. Para simular ese efecto, habría que eliminar el nodo caído del shard, entero, con la función remove. Entonces, para recuperar los datos, se podría hacer comprobando qué shards son más cortos de lo que deberían (3 en nuestro caso) y en ellos incluir un nuevo nodo. Después se puede hacer una copia en el nuevo nodo del shard, a partir de las copias. En este caso, el nuevo shard no sería nunca el principal, se añadiría el último, a menos que implemente una lógica de reordenamiento.

# Simular fallo total de un nodo
nodo_fallido = random.randint(0, 4)
print(f"Simulando fallo total del nodo {nodo_fallido}")

# Eliminar el nodo fallido de todos los shards
for shard_id in shards:
    if nodos[nodo_fallido] in shards[shard_id]:
        shards[shard_id].remove(nodos[nodo_fallido])

# Crear un nuevo nodo con el mismo ID que el nodo fallido
nuevo_nodo = Nodo(nodo_fallido)
nodos[nodo_fallido] = nuevo_nodo

# Añadir el nuevo nodo a los shards en la última posición
for shard_id in shards:
    if len(shards[shard_id]) < nodos_por_shard:  # Si el shard tiene espacio
        shards[shard_id].append(nuevo_nodo)

# Recuperar datos de las réplicas y asignarlos al nuevo nodo
print(f"Recuperando datos del nodo {nodo_fallido} a partir de las réplicas...")
for shard_id, nodos_shard in shards.items():
    if nuevo_nodo in nodos_shard:  # Si el nuevo nodo está en este shard
        # Obtener datos de las réplicas
        datos_replica = {}
        for nodo in nodos_shard:
            if nodo != nuevo_nodo:  # Excluir el nuevo nodo al obtener los datos
                datos_replica.update(nodo.datos)
        # Asignar los datos al nuevo nodo
        nuevo_nodo.datos.update(datos_replica)

# Depuración: Comprobar que los datos vuelven a estar en el nodo fallido, pero el último
for clave in datos:
    shard = obtener_shard(clave, num_shards)
    nodos_con_clave = [nodo.id_nodo for nodo in shards[shard] if clave in nodo.datos]
    print(f"Clave: {clave}, Nodos: {nodos_con_clave}")
"""